package xh.collection.sort;

/**
 * 堆排序
 * @author Administrator
 *
 */

public class HeapSort {
	
	public static void main(String[] args) {  
        int[] data5 = new int[] { 5, 3, 6, 2, 1, 9, 4, 8, 7 };  
        print(data5);  
        heapSort(data5);  
        System.out.println("排序后的数组：");  
        print(data5);  
    }  
  
    public static void swap(int[] data, int i, int j) {  
        if (i == j) {  
            return;  
        }  
        data[i] = data[i] + data[j];  
        data[j] = data[i] - data[j];  
        data[i] = data[i] - data[j];  
    }  
  
    public static void heapSort(int[] data) {  
        for (int i = 0; i < data.length; i++) {  
            createMaxdHeap(data, data.length - 1 - i);  
            swap(data, 0, data.length - 1 - i);  
            print(data);  
        }   
    }  
  
    public static void createMaxdHeap(int[] data, int lastIndex) {  
        for (int i = (lastIndex - 1) / 2; i >= 0; i--) {  
            // 保存当前正在判断的节点  
            int k = i;  
            // 若当前节点的子节点存在  
            while (2 * k + 1 <= lastIndex) {  
                // biggerIndex总是记录较大节点的值,先赋值为当前判断节点的左子节点  
                int biggerIndex = 2 * k + 1;  
                if (biggerIndex < lastIndex) {  
                    // 若右子节点存在，否则此时biggerIndex应该等于 lastIndex  
                    if (data[biggerIndex] < data[biggerIndex + 1]) {  
                        // 若右子节点值比左子节点值大，则biggerIndex记录的是右子节点的值  
                        biggerIndex++;  
                    }  
                }  
                if (data[k] < data[biggerIndex]) {  
                    // 若当前节点值比子节点最大值小，则交换2者得值，交换后将biggerIndex值赋值给k  
                    swap(data, k, biggerIndex);  
                    k = biggerIndex;  
                } else {  
                    break;  
                }  
            }  
        }  
    }  
  
    public static void print(int[] data) {  
        for (int i = 0; i < data.length; i++) {  
            System.out.print(data[i] + "\t");  
        }  
        System.out.println();  
    }  
	
	/*
	 * 
	//堆排序
	public void heapSort(int[] a,int n){
		int i;
		for(i = n ;i > 1;i--){
			swap(a,i,1);
			sink(a,i,1);
		}
	}
	
	//建堆,将一个普通的数组建成一个堆呢，那就需要对当前堆中的非叶子节点进行sink操作，最后达到堆的要求
	public void buildHeap(int[] a,int n){
		int i;
		for(i = (n/2);i>=1;i--){
			sink(a,n,i);
		}
	}

	
	//插入元素
	public void swim(int[] a,int k){
		int j = 0;
		while(k > 0){
			j = k /2;
			if(a[j] < a[k]){
				swap(a,j,k);
				k = j;
			}else
				break;
		}
	}
	
	//n是节点总数，删除总是从根节点开始
	public void sink(int[] a, int n,int k){
		while(2*k < n){
			int j = 2*k;
			if(j < n && a[j] < a[j+1])
				j++;
			if(a[k] < a[j]){
				swap(a,k,j);
				k = j;
			}else
				break;
				
		}
	}
	
	//交换数据的两个元素
	public void swap(int[] a,int i,int j){
		int tmp = a[i];
		a[i]  = a[j];
		a[j] = tmp;
	}
	
	public static void main(String[] args){
		//数组总共为7个数，但为了方便，建8个，第一位不存值，为了方便，放了0；
		int[] a = {0,3,4,6,37,1,5,2};
		HeapSort hs = new HeapSort();
		hs.buildHeap(a, 7);
		hs.heapSort(a, 7);
		System.out.print(Arrays.toString(a));
	}
	
	*/
}
